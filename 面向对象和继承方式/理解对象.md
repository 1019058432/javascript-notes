# 理解对象

面向对象的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象创建自定义对象的最简单方式就是创建一个 Object 的实例，然后再为它添加属性和方法；

    var person = new Object();//Object就是一个类；person是Object的一个实例；
    person.name = "zab";
    person.age = 26;
    person.job = "WEB";
    person.sayName = function(){
        console.log(this.name);
    };

上面的例子创建了一个名为 person 的对象，并为它添加了三个属性（ name 、 age 和 job ）和一个方法（ sayName() ）。其中， sayName() 方法用于显示 this.name （将被解析为 person.name ）的值。

不推荐这么写，推荐字面量的创建方式。前面的例子用对象字面量语法可以写成这样;

    var person = {
        name: "zab",
        age: 26,
        job: "WEB",
        sayName: function(){
            console.log(this.name);
        }
    };

字面量的写法，可以更像一块；而且传参的时候，可以更直接的看到传的是哪些参数；

ECMA-262 把对象定义为：**“无序属性的集合，其属性可以包含基本值、对象或者函数。”** 严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把 ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。每个对象都是基于一个引用类型创建的，

- 知识点一、属性类型
- 知识点二、定义多个属性
- 知识点三、读取属性的特性

### 知识点一、属性类型

ECMAScript 中有两种属性：**数据属性**和**访问器属性**。

- 数据属性
- 访问器属性

ECMA-262 第 5 版在定义只有内部才用的特性（attribute）时，描述了属性（property）的各种特征。ECMA-262 定义这些特性是为了实现 JavaScript 引擎用的，因此在 JavaScript 中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对儿方括号中，例如 [[Enumerable]] 。

##### 数据属性

**数据属性指某个数据值是否可以读取和写入值**；数据属性有4个描述其行为的特性；

- [[enumerable]]    是否可枚举 / 是否可读，该特性默认是true；（表示能否通过for-in循环读取到对象的属性； ）
- [[writable]]      是否可写，该特性默认是true；（表示能够修改属性的值）
- [[configurable]]  是否可删改，该特性默认是true；（表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。）
- [[value]]         某个属性的属性值；默认是undefined；（读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。）

像前面的例子，他的 Enumerable / Writable / Configurable 默认都是true；name属性的Value被设置为"zab";对该值的任何修改都会在这个属性上反应出来；

**修改数据属性:Object.defineProperty(object,name,{})**

要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty() 方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是： configurable 、 enumerable 、 writable 和 value 。设置其中的一或多个值，可以修改对应的特性值。

> 默认的时候

      var person = {
          name: "zab",
          age: 26,
          job: "WEB",
          sayName: function(){
              console.log(this.name);
          }
      };
      console.log(person.name,person.age);
      person.name="zab MODI"
      delete person.age;
      console.log(person.name,person.age);
      for (var key in person) {
        console.log("枚举对象的属性:",key);
      }

> 使用属性的时候；

      var person = {
          name: "zab",
          age: 26,
          job: "WEB",
          sayName: function(){
              console.log(this.name);
          }
      };
      console.log(person.name);//zab 26
    Object.defineProperty(person,"name",{//注意：属性一定要放在字符串中；
      enumerable:false,
      writable:false,
      configurable:false,
      value:"zab1"
    });
    console.log(person.name);//zab1
    person.name="zab MODI"
    console.log(person.name);//zab1,person.name="zab MODI"无效；
    delete person.name;
    console.log(person.name);//zab1 命令delete person.name;无效；
    
    for (var variable in person) {
        console.log("枚举对象的属性,是否有name:",variable);//其它的所有属性都枚举出来了，就是name没有枚举出来；
    }

**如果把某个特性设置为false，假如再次尝试操作它，在非严格模式下，操作将被忽略（在非严格模式下什么也不会发生）；在严格模式下，操作将会导致抛出错误。**

**而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了。此时，再调用 Object.defineProperty() 方法修改除 writable 之外的特性，都会导致错误：**

例子：

