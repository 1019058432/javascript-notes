# 创建对象的方式


创建对象的方式，最基本的有5种模式：**单例模式**、**工厂模式**、**构造函数模式**、**原型模式**、**构造函数+原型模式**;

其它的就是在原型模式，或者构造函数模式的基础上再次改造的模式；

- 知识点一：单例模式
- 知识点二：工厂模式
- 知识点三：构造函数模式
- 知识点四：原型模式
- 知识点五：构造函数+原型模式
- 知识点六：其它扩展模式
	- 知识点六.1：动态原型模式
	- 知识点六.2：寄生构造函数模式
	- 知识点六.3：稳妥构造函数模式

# 知识点一：单例模式

单例模式：就是对象类型; Object构造函数或对象字面量都可以用来创建单个对象,下面是字面量的单例模式;(原生的Object构造函创建对象的方式，在某种意义上也是属于单例模式)


	var person1 = {
	  name: "朱",
	  age: 18,
	  say:function(){
	    console.log("我是person1的say方法");
	  }
	};
	var person2 = {
	  name: "安",
	  age: 28,
	  say:function(){
	    console.log("我是person2的say方法");
	  }
	};
	console.dir(person1);//person1是一个单例模式
	console.dir(person2);//person2是一个单例模式


把描述同一个事物(同一个对象)的属性和方法放在一个内存空间下,起到了分组的作用,这样不同事物之间的属性即使属性名相同,相互也不会发生冲突

我们把这种分组编写代码的模式叫做"单例模式"

在单例模式中我们把person1或者person2也叫做"命名空间"

单例模式，因为简单易用的原因，是封模块和日常写代码中，最常用的创建方式；

##### 单例模式的优点 

直观，易用，对象的可塑性非常强；

##### 单例模式用在模块化开发中

单例模式是一种项目开发中经常使用的模式,项目中使用单例模式来进行"模块化"开发也是很常见的；

"模块化":对于一个相对来说比较大的项目,需要多人协作的开发的,我们一般情况下会根据当前项目的需求划分成几个功能版块,每个人负责一部分,同时开发，在需要用到的某个功能的时候，直接引用该模块即可；简单，易用，拆卸方便；

	//公共模块
	var utils = {
	  select: function () {
	    console.log("utils.select");
	  }
	};
	
	//pageUtilitly的一个主文件
	var pageUtilitly = {
	    init:function(){
	      console.log("现在开始运行bind和select中的代码");
	      this.bind();//运行绑定相关的方法；
	      this.select();//运行选择相关的方法，如果暂时不需要，直接注释本行代码即可
	    },
	    bind: function () {
	      var self=this;
	      self.clickEven();//在自己的命名空间下调用自己命名空间的方法
	    },
	    select:function(){
	      utils.select();//在自己的命名空间下调用其他命名空间的方法
	    },
	    clickEven:function(){
	        console.log("pageUtilitly.clickEven");
	    }
	};
	pageUtilitly.init();


##### 单例模式的缺点

面向对象，创建对象，有点类似做衣服，单例模式的优点是可定制性非常强，有点类似手工做衣服；虽然可塑性非常强，但是缺点就是如果批量做衣服的时候，效率就非常差；如下，tShirt1和tShirt2里面的方法和属性可以随意的改变，可塑性非常强；

	var tShirt1 = {
	    name: "t-shirt-1",
	    size: "xl",
	    color: "红",
	    hasEffect: function () {
	        console.log("这件T恤:" + this.name + "," + this.size + "," + this.color +",自带装逼效果！");
	    }
	};
	var tShirt2 = {
	    name: "t-shirt-2",
	    size: "xxxl",
	    color: "黑",
	    hasEffect: function () {
	        console.log("这件T恤:" + this.name + "," + this.size + "," + this.color +",自带撩妹效果！");
	    }
	};
	
	tShirt1.hasEffect();
	tShirt2.hasEffect();

> 单例模式虽然解决了分组和创造对象的作用,但是不能实现批量的生产,属于手工作业模式;
> 假设我要100件tShirt2这种自带撩妹效果的T恤，就需要重复写100次；var tShirt2 这里的代码
> 这就引申到另外的一种模式："工厂模式"

# 知识点二：工厂模式

虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。

工厂模式是软件工程领域一种广为人知的设计模式，考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装特定接口的对象，

工厂模式：说白了就是一种函数类型；

- 把实现同一件事情的相同的代码放到一个函数中，以后如果在想实现这个功能，不需要从新的编写这些代码来了，只需要执行当前的函数即可
- "函数的封装" -->**"高内聚低耦合":减少页面中的冗余代码,提高代码的重复利用率；**（工厂模式的优点就是函数模式的特点）

如下面的例子所示。

	function createTshirt(name, size, color){
	    var o = new Object();
	    o.name = name;
	    o.size = size;
	    o.color = color;
	    o.sayName = function(){
	        console.log("这件T恤:" + this.name + "," + this.size + "," + this.color +",自带撩妹效果！");
	    };
	    return o;
	}
	var tShirt1 = createTshirt("tShirt1", "xl", "红");
	var tShirt2 = createTshirt("tShirt2", "xxxl", "黑");
	var tShirt3 = createTshirt("tShirt3", "xxxl", "黑");
	var tShirt4 = createTshirt("tShirt4", "xxxl", "黑");

函数 createTshirt() 能够根据接受的参数来构建一个包含所有必要信息的 T恤 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript的发展，又一个新模式出现了。

JS是一门轻量级的脚本"编程语言"(HTML+CSS不属于编程语言,属于标记语言)

.net C# php Java c c++ vb vf object-c ....;所有的编程语言都是面向对象开发的->类的继承、封装、多态

> 继承:子类继承父类中的属性和方法
> 多态:当前方法的多种形态->后台语言中:多态包含重载和重写

> “JS中不存在重载”,方法名一样的话,后面的会把前面的覆盖掉,最后只保留一个
> "JS中有一个操作类似重载但是不是重载":我们可以根据传递参数的不一样的,实现不同的功能，属于函数的多态性；

	function sum(num) {
	    if (typeof num === "undefined") {
	        console.log("您没有传参啊，请仔细检查");
	        return;
	    }
	    console.log(num);
	}
	sum(100);
	sum();

#####工厂模式的缺点;

# 知识点三：构造函数模式